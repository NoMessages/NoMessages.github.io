{"meta":{"title":"Share Cat","subtitle":"Lover & Sharer","description":"","author":"JHua_Rocy","url":"https://NoMessages.github.io.git","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-06-11T03:09:44.000Z","updated":"2020-06-13T04:19:38.765Z","comments":false,"path":"404/index.html","permalink":"https://nomessages.github.io.git/404/index.html","excerpt":"","text":""},{"title":"medis","date":"2020-06-11T10:23:38.000Z","updated":"2020-06-13T04:29:12.032Z","comments":true,"path":"about/index.html","permalink":"https://nomessages.github.io.git/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-06-11T09:25:30.000Z","updated":"2020-06-13T04:14:03.853Z","comments":true,"path":"categories/index.html","permalink":"https://nomessages.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-06-11T10:23:38.000Z","updated":"2020-06-13T04:14:23.164Z","comments":true,"path":"contact/index.html","permalink":"https://nomessages.github.io.git/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-06-11T13:25:30.000Z","updated":"2020-06-13T04:14:37.377Z","comments":true,"path":"friends/index.html","permalink":"https://nomessages.github.io.git/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-12T01:45:24.000Z","updated":"2020-06-13T04:30:45.541Z","comments":true,"path":"tags/index.html","permalink":"https://nomessages.github.io.git/tags/index.html","excerpt":"","text":"FirTags – &gt; Link"},{"title":"thrid","date":"2020-06-12T08:41:25.000Z","updated":"2020-06-12T08:41:25.229Z","comments":true,"path":"thrid/index.html","permalink":"https://nomessages.github.io.git/thrid/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringMVC 学习心得（七）","slug":"SpringMVC-7","date":"2020-06-14T03:07:02.000Z","updated":"2020-06-14T03:14:01.890Z","comments":true,"path":"2020/06/14/springmvc-7/","link":"","permalink":"https://nomessages.github.io.git/2020/06/14/springmvc-7/","excerpt":"","text":"小编一路学习过来整理了文件上传的演化过程，随着框架的使用，使得文件上传的过程越来越简化方便，也正是因为框架的帮助，使得开发更加的简洁，下面小编整理了整个文件上传的变化过程！ 1)、普通文件上传1.普通文件上传代码如下 @RequestMapping(\"/testFileUp\") public String testFileUp(HttpServletRequest request) throws Exception { // 获取原生真实路径 String realPath = request.getSession().getServletContext().getRealPath(\"/uploads/\"); //创建文件 ， 判断是否存在此文件夹 File file = new File(realPath); if(!file.exists()){ boolean mkdirs = file.mkdirs(); System.out.println(\"isCreating? \"+mkdirs); } //打印文件地址便于查看 System.out.println(\"file exitst ...\" + realPath); //配置DiskFile工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); //使用Servlet ServletFileUpload fileUpload = new ServletFileUpload(factory); //解析request List&lt;FileItem> items = fileUpload.parseRequest(request); //判断文件是什么类型的 for (FileItem item : items) if (item.isFormField()) { //普通类型 String name = item.getFieldName(); if (name.equals(\"name\")) { //输出表单字段的值 System.out.print(item.getString(\"UTF-8\")+\"上传了文件。\"); } } else { System.out.println(\"文件字段\"); //文件类型 //1.获取文件名字 String name = item.getName(); //添加一个随机值与文件名拼串 String s = UUID.randomUUID().toString().replaceAll(\"-\", \"\").toUpperCase(); //拼串 name = s+\"_\"+name; //上传文件 item.write(new File(realPath, name)); //删除零食文件 item.delete(); } return \"success\"; } 2)、SpringMVC文件上传@RequestMapping(\"/testFileUp2\") public String testFileUp2(HttpServletRequest request, MultipartFile filename) throws Exception { //原生实现文件上传 // 获取原生真实路径 String realPath = request.getSession().getServletContext().getRealPath(\"/uploads/\"); //创建文件 ， 判断是否存在此文件夹 File file = new File(realPath); if(!file.exists()){ boolean mkdirs = file.mkdirs(); System.out.println(\"isCreating?\"+mkdirs); } System.out.println(\"file exitst ...\" + realPath); //获取到上传文件的名称 == item.getFileName() String name = filename.getOriginalFilename(); String s = UUID.randomUUID().toString().replaceAll(\"-\", \"\").toUpperCase(); name = s+\"_\"+name; //上传文件 filename.transferTo(new File(realPath,name)); return \"success\"; } 补充：SpringMVC提供了了MultipartFile对象，该对象表示上传的文件，要求变量名称必须和表单file标签的name属性名称相同 可以通过配置配置文件的方式限制文件上传限制（ID必须为multipartResolver） &lt;!-- 配置文件管理器 --> &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"> &lt;property name=\"maxUploadSize\" value=\"#{1024 * 10 * 100}\"/> &lt;/bean> 3)、跨服务器文件上传1).文件上传逻辑图 2).导入jersey坐标，用来实现跨服务器上传&lt;dependency> &lt;groupId>com.sun.jersey&lt;/groupId> &lt;artifactId>jersey-core&lt;/artifactId> &lt;version>1.18.1&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.sun.jersey&lt;/groupId> &lt;artifactId>jersey-client&lt;/artifactId> &lt;version>1.18.1&lt;/version> &lt;/dependency> 3).跨服务器代码实现@RequestMapping(\"/testFileUp3\") public String testFileUp3( MultipartFile upload) throws Exception { //自定义路径 String path = \"http://localhost:9090/uploads/\"; //获取文件名 String name = upload.getOriginalFilename(); String s = UUID.randomUUID().toString().replaceAll(\"-\", \"\").toUpperCase(); name = s+\"_\"+name; //创建客户端对象 Client client = new Client();//com.sun.jersey.api.client.Client; 注意是jerse包下的Client //连接图片服务器 WebResource webResource = client.resource(path + name);//因为path后面加了 ‘/ ’ 所以这里直接拼接就行了 //上传文件 webResource.put(upload.getBytes());//提交字节上传文件 return \"success\"; } 4).可能会出现的异常1）、403：return a response status of 403 Forbidden原因：在tomcat中，是由于”写入”访问被禁止而造成的，当试图将文件上载到目录或在目录中修改文件，但该目录不允许”写”访问时就会出现此种错误。 解决：修改为可接受传入即可，即将value改为false 2）、500：org.springframework.web.multipart.MaxUploadsSizeExceedException原因：小编之前定义的最大上传文件大小字节为1024*1000所以只有1024000个字节大小，但是图片的大小为1314599个字节大小，所以上传就没有成功，所以这个异常修改上传最大字节即可 解决：修改最大值即可 5).最终效果图上传成功！","categories":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/categories/Spring/"},{"name":"SpringMVC","slug":"Spring/SpringMVC","permalink":"https://nomessages.github.io.git/categories/Spring/SpringMVC/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://nomessages.github.io.git/tags/SpringMVC/"}],"author":"JHua_Rocy"},{"title":"SpringMVC 学习心得（六）","slug":"SpringMVC-6","date":"2020-06-14T03:04:49.000Z","updated":"2020-06-14T03:11:19.719Z","comments":true,"path":"2020/06/14/springmvc-6/","link":"","permalink":"https://nomessages.github.io.git/2020/06/14/springmvc-6/","excerpt":"","text":"1)、静态资源拦截问题 DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而不能被使用。解决问题就是需要配置静态资源不进行拦截，在springmvc.xml配置文件添加如下配置 mvc:resources标签配置不过滤 1). location元素表示webapp目录下的包下的所有文件 2). mapping元素表示以/static开头的所有请求路径，如/static/a 或者/static/a/b &lt;!-- 设置静态资源不过滤 --> &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/> &lt;!-- 样式 --> &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/> &lt;!-- 图片 --> &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/> &lt;!-- javascript --> 2)、json转换为对象1).实体类User public class User implements Serializable { private String username;//姓名 private String password;//密码 private Integer age;//年龄 } 2).前端页面编写AJAX（原生阿贾克斯的实现） &lt;script> /* 全局函数 */ $(function () { $(\"#btn01\").click(function () { $.ajax({ url:\"test/testAjax\", //请求路径 contentType:\"application/json;charset=utf-8\", //设置编码请求格式 data:'{\"username\":\"哈哈\",\"password\":\"123445\",\"age\":23}', //传入的数据 datatype:\"json\", //数据类型 type:\"post\", //请求类型 success:function (data) { //请求成功返回类型 alert(data) } }) }); }); &lt;/script> 3).标注controller为回写数据（@ResponseBody）注解，如果不了解这些注解，小编给出传送门—–&gt; SpringMVC 学习笔记心得（四）常用注解详解 @RequestMapping(\"/testAjax\") public @ResponseBody User testAjax(@RequestBody User user) { System.out.println(user); user.setPassword(\"123123\"); user.setAge(29); return user; } 4). json字符串和JavaBean对象互相转换的过程中，需要使用jackson的jar包 &lt;dependency> &lt;groupId>com.fasterxml.jackson.core&lt;/groupId> &lt;artifactId>jackson-databind&lt;/artifactId> &lt;version>2.9.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.fasterxml.jackson.core&lt;/groupId> &lt;artifactId>jackson-core&lt;/artifactId> &lt;version>2.9.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.fasterxml.jackson.core&lt;/groupId> &lt;artifactId>jackson-annotations&lt;/artifactId> &lt;version>2.9.0&lt;/version> &lt;/dependency> 5).返回的data就被转换为对象了","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://nomessages.github.io.git/categories/SpringMVC/"},{"name":"Spring","slug":"SpringMVC/Spring","permalink":"https://nomessages.github.io.git/categories/SpringMVC/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://nomessages.github.io.git/tags/SpringMVC/"}],"author":"JHua_Rocy"},{"title":"SpringMVC 学习心得（五）","slug":"SpringMVC-5","date":"2020-06-14T03:00:19.000Z","updated":"2020-06-14T03:15:00.309Z","comments":true,"path":"2020/06/14/springmvc-5/","link":"","permalink":"https://nomessages.github.io.git/2020/06/14/springmvc-5/","excerpt":"","text":"Springmvc中响应数据和结果视图的情况有很多，以下是小编总结的内容。 1.返回值分类1）、字符串 @RequestMapping(\"/hello\") public String hello(){ return \"success\"; } springmvc会通过走视图解析器的方式去跳转返回的’success’界面,视图解析器中，自己定义的前缀prefix 和后缀 subffix再和返回的’success’拼接起来，最终就会跳转到对应的/WEB-INF/pages/success.jsp &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/> &lt;property name=\"suffix\" value=\".jsp\"/> &lt;/bean> 这里需要注意的就是，如果自己在开发的过程中没有配置视图解析器，那么就会默认跳向根目录下的返回值（return “success”），这里当然会抛404，因为success是无法找到的，所以要在webapp下创建success.jsp文件并且，将返回值完善为（return “success.jsp”）才可以访问到 2）、void @GetMapping(\"/success\") public void index(){ System.out.println(\"index method ...\"); } 如果控制器的方法返回值编写成void，执行程序报404的异常，默认查找JSP页面没有找到。1. 默认会跳转到@GetMapping(value=”/success”) success.jsp的页面（如果配置了视图解析器，没配置会抛500异常）如下图2. 可以使用请求转发或者重定向跳转到指定的页面2.1 forward请求转发： System.out.println(\"重定向或者请求转发\"); // 请求转发 request.getRequestDispatcher(\"/WEB-INF/pages/forward.jsp\").forward(request, response); 2.2 redirect重定向： // 重定向 response.sendRedirect(request.getContextPath()+\"/redirect.jsp\"); response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"text/html;charset=UTF-8\"); // 直接响应数据 response.getWriter().print(\"你好\"); 转发和重定向需要注意的地方是，重定向是没有权限访问WEB-INF下的文件的，也可以说是WEB-INF下的文件受保护，无法被重定向到，所以如果是请求WEB-INF下的文件一定会报404（如下图所示，所以小伙伴们就不要过多去纠结这个问题了） 3）、ModelAndView@GetMapping(\"/model\") public ModelAndView getView(){ ModelAndView mv = new ModelAndView(); // 跳转到list.jsp的页面 mv.setViewName(\"success\"); return mv; } ModelAndView底层实现其实也是request的转发请求，他也有mv.addObject()方法，携带参数可以在此次转发请求中获取生效，mv.setViewName()方法也是会走视图解析器的,所以最终会去视图解析器配置的/Prefix+’设置的路径’+Subfix路径 2. SpringMVC框架提供的转发和重定向1)、forward请求转发 /* 使用forward关键字进行请求转发 * forward:转发的JSP路径\"，不走视图解析器了，所以需要编写完整的路径 * @return * @throws Exception */ @RequestMapping(\"/test\") public String delete() throws Exception { System.out.println(\"test...\"); // return \"forward:/WEB-INF/pages/success.jsp\"; return \"forward:/forward/test.jsp\"; } 2)、redirect重定向 @GetMapping(\"/guess\") public String guess(){ return \"redirect:/forward/test.jsp\"; } 这里注意，转发和重定向都不会走视图解析器的，会直接在webapp下寻找forward文件夹下的test.jsp文件，但是请求转发（forward）是可以请求WEB-INF文件下的资源，而重定向（redirect）不能 3)、redirect和forward区别？小编自己总结了一下： 要素 forward redirect 请求次数 1次 2次 请求路径 无变化 重定向网址 数据共享 同一个request，可以共享数据 两次请求两个request，不能共享数据 请求写法 request.getRequestDispatcher(资源路径).forward(request, response) response.sendRedirect(资源路径); 本质区别 转发是服务器行为 重定向是客户端行为 转向速度 较快 较慢 权限访问 可以访问WEB-INF文件夹下的文件 不可以访问WEB-INF文件夹下的文件 通过以后的学习，小编会不断的补充和完善，希望能够帮助到大家","categories":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/categories/Spring/"},{"name":"SpringMVC","slug":"Spring/SpringMVC","permalink":"https://nomessages.github.io.git/categories/Spring/SpringMVC/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://nomessages.github.io.git/tags/SpringMVC/"}],"author":"JHua_Rocy"},{"title":"SpringMVC 学习心得(四)","slug":"SpringMVC-4","date":"2020-06-14T02:55:41.000Z","updated":"2020-06-14T03:24:39.005Z","comments":true,"path":"2020/06/14/springmvc-4/","link":"","permalink":"https://nomessages.github.io.git/2020/06/14/springmvc-4/","excerpt":"","text":"在springmvc中，许多注解能够帮助我们大大提高开发效率，这里小编讲述一下最常见的七种注解 1. RequestParam注解 作用：把请求中的指定名称的参数传递给控制器中的形参赋值 属性 value：请求参数中的名称 required：请求参数中是否必须提供此参数，默认值是true，必须提供 概念引导：/* 接收请求 @return */ @RequestMapping(path=\"/testParam\") public String testParam(@RequestParam(value=\"username\",required=false)String name) { System.out.println(name); return \"success\"; } 注意：传值要与注解中的参数对应，否则将不会被自动封装上，则会变成null值，2.当添加了注解required=false，如果不参入参数也不会抛出400请求错误，如果不添加，默认需要传入参数，否则会报400错误 2. RequestBody注解 作用：用于获取请求体的内容（注意：get方法不可以） 属性 required：是否必须有请求体，默认值是true 2.1 引导案例：​ @RequestMapping(value = \"/testBody\") public String testBody(@RequestBody String body){ System.out.println(\"testBody Method ... \"); System.out.println(body); return \"success\"; } 2.2 表单内容如下：&lt; form action=\"/test/testBody\" method=\"post\"> 姓名：&lt;input type=\"text\" name=\"username\" /> 密码：&lt;input type=\"text\" name=\"password\" /> 金额：&lt;input type=\"text\" name=\"money\" /> &lt;input type=\"submit\" value=\"提交\" /> &lt; /form> 2.3 提交页面： 输出结果：testBody Method …username=%C3%A7%C2%BD%C2%97%C3%A4%C2%B8%C2%BD%C3%A4%C2%B8%C2%9D%C3%A5%C2%A1%C2%94&amp;password=1024&amp;money=200.5 2.4 注意：解决乱码的问题：在web.xml中配置&lt;!-- 配置过滤器 --> &lt;filter> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>UTF-8&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> deploy服务器，输出结果：testBody Method …username=罗丽丝塔&amp;password=1024&amp;money=200.5 3. PathVariable注解 作用：拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符 属性 value：指定url中的占位符名称 Restful风格的URL 请求路径一样，可以根据不同的请求方式去执行后台的不同方法 restful风格的URL优点 结构清晰 符合标准 易于理解 扩展方便 3.1 引导案例：@RequestMapping(\"/testVaripoty/{id}\") public String testVaripoty(@PathVariable(name = \"id\") String id){ System.out.println(\"testVaripoty Method ... \"); System.out.println(id); return \"success\"; } 3.2 传值测试：测试PathVariable 3.3 结果输出：testVaripoty Method ... 100 这里注意：这里的写法格式是/路径/{参数名},在传值的时候也是“路径/值”,在传参数的时候不要习惯性的把 ‘ / ’ 写成 ’？‘ 4. RequestHeader注解 作用：获取指定请求头的值 属性 value：请求头的名称 4.1 引导案例：@RequestMapping(path=\"/testHeader\") public String testHeader(@RequestHeader(value=\"Accept\") String header) { System.out.println(header); return \"success\"; } 5. CookieValue注解 作用：用于获取指定cookie的名称的值 属性：value：cookie的名称 5.1 引导案例：@RequestMapping(path=\"/testCookie\") public String testCookie(@CookieValue(value=\"JSESSIONID\") String cookieValue) { System.out.println(cookieValue); return \"success\"; } 5.2 注意：JSESSIONID是固定写法，在浏览器中可以看到的，这里写错了也是获取不到的6. ModelAttribute注解 作用 出现在方法上：表示当前方法会在控制器方法执行前线执行。 出现在参数上：获取指定的数据给参数赋值。 两种实现方式：@ModelAttribute中设置返回对象 ； 使用map集合 + @ModelAttribute ( value = key) 的形式 完成 6.1 引导案例：（返回对象方式） @ModelAttribute public UserAccount firModol(String username){ System.out.println(\"welcome ...\" + username); //模拟查询数据库操作 UserAccount userAccount = new UserAccount(); userAccount.setUsername(username); userAccount.setPassword(\"1234465\"); return userAccount; } @RequestMapping(\"/testModolAttribute\") public String testModolAttribute(UserAccount userAccount){ System.out.println(userAccount); return \"success\"; } 6.2 表单填写： 输出结果：welcome …罗丽丝塔UserAccount{username=’罗丽丝塔’, password=’33333’, money=null} 这里小编对为什么密码是33333做一个解释，@ModelAttribute表示最先被执行，小编在里面设置了密码，模拟查询数据库，但是此时小编提交的新的数据过来，于是将原来的数据覆盖了，就变成了表格中填写的数据，有点类似于修改个人资料的操作 6.3 引导案例（MAP+@ModelAttribute）@ModelAttribute public void firModol(String username , Map&lt;String , UserAccount> map){ System.out.println(\"welcome ...\" + username); UserAccount userAccount = new UserAccount(); userAccount.setUsername(username); userAccount.setPassword(\"1234465\"); map.put(\"userAccounts\",userAccount); } @RequestMapping(\"/testModolAttribute\") public String testModolAttribute(@ModelAttribute(value = \"userAccounts\") UserAccount userAccount){ System.out.println(userAccount); return \"success\"; } 6.4 form表单填写： 6.5 输出结果：welcome ...奥尼斯汀 UserAccount{username='奥尼斯汀', password='1024', money=null} 7. SessionAttributes注解 作用：用于多次执行控制器方法间的参数共享 属性：value：指定存入属性的名称 7.1 引导案例：创建TestSessionAttributes类@Controller @SessionAttributes(value = \"msg\")//将msg存入Session域中 public class TestSessionAttributes { @RequestMapping(\"/setSessionAttribute\") //Model底层实现就是存入request域中 public String setSessionAttribute(Model model){ System.out.println(\"setSessionAttribute ...\"); model.addAttribute(\"msg\",\"美美\"); return \"success\"; } } 7.2 获取session@RequestMapping(\"/getSessionAttribute\") public String getSessionAttribute(ModelMap modelmap){ System.out.println(\"getSessionAttribute ...\"); String msg = (String) modelmap.get(\"msg\"); System.out.println(\"msg : \" + msg); return \"success\"; } 7.3 删除Session域@RequestMapping(\"/delSessionAttribute\") public String delSessionAttribute(SessionStatus sessionStatus){ System.out.println(\"delSessionAttribute ...\"); sessionStatus.setComplete(); return \"success\"; } 7.4 jsp页面编写&lt;a href=\"setSessionAttribute\">setSessionAttribute&lt;/a> &lt;a href=\"getSessionAttribute\">getSessionAttribute&lt;/a> &lt;a href=\"delSessionAttribute\">delSessionAttribute&lt;/a> 7.5 success界面编写（注意不要忽略isELIgnored=false）&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %> &lt;html> &lt;head> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;h1>Success&lt;/h1> ${msg} ${sessionScope} &lt;/body> &lt;/html> 7.6 页面测试7.6.1 点击setSessionAttribute 7.6.2 点击getSessionAttribute 7.6.3 点击delSessionAttribute 这里还有个美美是因为request域中没有被清除，但是session域中已经被清楚了 这里就是常用的七大注解了，如有讲错的地方欢迎大家指正","categories":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/categories/Spring/"},{"name":"SpringMVC","slug":"Spring/SpringMVC","permalink":"https://nomessages.github.io.git/categories/Spring/SpringMVC/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://nomessages.github.io.git/tags/SpringMVC/"}],"author":"JHua_Rocy"},{"title":"SpringMVC 学习心得（三）","slug":"SpringMVC-3","date":"2020-06-14T02:41:21.000Z","updated":"2020-06-14T03:13:54.594Z","comments":true,"path":"2020/06/14/springmvc-3/","link":"","permalink":"https://nomessages.github.io.git/2020/06/14/springmvc-3/","excerpt":"","text":"应用场景：我们在数据库中定义了出生日期字段类型为date，在浏览器中的form表单中填写数据，springmvc内置了十种过滤器模式，当你将日期写成xx/xx/xx格式可以被内置解析，但是xx-xx-xx这种格式会抛出 400 Bad Request请求异常，所以我们自定义过滤器配置使用 1.实现接口Converter&lt;S,T&gt;1.1 创建StringDateFormat类 /* 类型转换 */ public Date convert(String s) { if (s == null) { throw new RuntimeException(\"参数不能为空\"); } try { // 解析字符串 Date date = df.parse(source); return date; DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\"); Date date = df.parse(s); return date; } catch (Exception e) { throw new RuntimeException(\"类型转换错误\"); } } 1.2 在springmvc配置文件中配置ConversionServiceFactoryBean工厂 &lt;bean class=\"org.springframework.context.support.ConversionServiceFactoryBean\" id=\"conversionService\"> &lt;property name=\"converters\"> &lt;set> &lt;bean class=\"cn.itcast.controller.StringDateFormate\">&lt;/bean> &lt;/set> &lt;/property> &lt;/bean> 1.3 模拟实体类public class UserAccount implements Serializable { private Date date; (...省略toString get() set() ) } 1.4 在没添加之前输入xx-xx-xx发出错误请求界面：2.编写Controller类 @RequestMapping(\"/getDate\") public String getDate(UserAccount account){ System.out.println(\"date : \" + account); return \"success\"; } 2.1 输入xx-xx-xx日期类型，控制台输出结果为： date : UserAccount{date=Tue Dec 11 00:00:00 CST 1212} 2.中文乱码问题解决 &lt;!-- 配置过滤器 --> &lt;filter> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>UTF-8&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> 好了，这就是简易自定义过滤器的使用了，有什么不同的见解可以一起探讨","categories":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/categories/Spring/"},{"name":"SpringMVC","slug":"Spring/SpringMVC","permalink":"https://nomessages.github.io.git/categories/Spring/SpringMVC/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://nomessages.github.io.git/tags/SpringMVC/"}],"author":"JHua_Rocy"},{"title":"SpringMVC 学习心得（二）","slug":"SpringMVC-2","date":"2020-06-14T02:41:17.000Z","updated":"2020-06-14T03:13:49.258Z","comments":true,"path":"2020/06/14/springmvc-2/","link":"","permalink":"https://nomessages.github.io.git/2020/06/14/springmvc-2/","excerpt":"","text":"在上一章节小编讲述了SpringMVC入门案例，通过配置 前端控制器 ， 视图解析器，初始化加载配置文件等等一系列步骤，下面小编继续讲解上章节的疑惑注解@RequestMapping 1 .@RequestMapping的几种形式 path 指定请求路径的url value value属性和path属性是一样的 mthod 指定该方法的请求方式（如果接受不在定义范围内的请求会抛404） params 指定限制请求参数的条件 headers 发送的请求中必须包含的请求头 1.1 path属性 @RequestMapping(path = \"/path\") public String pathTest(){ System.out.println(\"path\"); return \"success\"; } 1.2 value属性： // 2. value value属性和path属性是一样的 @RequestMapping(value = \"/value\") public String valueTest(){ System.out.println(\"value\"); return \"success\"; } 1.3 method属性：// 3. method 指定该方法的请求方式 @RequestMapping(value = \"/method\" , method = {RequestMethod.GET }) public String methodTest(){ System.out.println(\"method\"); return \"success\"; } 1.4 params属性：// 4. params 指定该方法的请求方式 @RequestMapping(value = \"/params\") public String paramsTest(String name , String password){ System.out.println(\"params\" + name + \":\" + password); return \"success\"; } 1.5 headers属性：// 5. headers 发送的请求中必须包含的请求头 @RequestMapping(value = \"/headers\" , headers = \"Accept\") public String headersTest(){ System.out.println(\"headers\"); return \"success\"; } 方法里面都是只是简单的输出了一句话，在失败的请求下，控制台是不会输出方法中的话的 1.6 创建index.jsp文件Path//测试path值方法 value//测试value值方法 method//测试method方法 params //测试携带参数方法 headers//测试是否包含请求头方法 1.7 测试执行结果如下path value method params Rocy:23 headers 这里有很多地方需要注意：1.method属性定义的（小编仅仅定义了method = {RequestMethod.GET },这里是标明除了GET请求可以被请求成功之外，其他的请求都会抛出400Bad Request错误声明，导致请求失败，不会进入方法，更不会输出方法中的内容）2.param属性定义的形参也是要和携带的参数一一对应的，如果形参与携带的参数不对应，那么值就不能自动封装上，便会出现null值打印的情况3.headers属性：如果不包含头信息也会抛出400异常错误 好了，这里就是SpringMVC的RequestMapping注解的属性使用了","categories":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/categories/Spring/"},{"name":"SpringMVC","slug":"Spring/SpringMVC","permalink":"https://nomessages.github.io.git/categories/Spring/SpringMVC/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://nomessages.github.io.git/tags/SpringMVC/"}],"author":"JHua_Rocy"},{"title":"SpringMVC 学习心得（一）","slug":"springMVC-8","date":"2020-06-14T02:34:14.000Z","updated":"2020-06-14T03:14:07.541Z","comments":true,"path":"2020/06/14/springmvc-8/","link":"","permalink":"https://nomessages.github.io.git/2020/06/14/springmvc-8/","excerpt":"","text":"在小编总结完Spring的学习笔记之后，紧接着更新SpringMVC的学习笔记，也正是因为SpringMVC是基于Spring的，在整理Spring学习心得的过程中，有很多半懵半懂的地方在整理的过程中慢慢理解，慢慢强化自己的知识点，也是小编在不断测试中不断尝试才整理出来的一套Spring学习心得（这里确实用了很久很久的时间），现在虽然小编对于SpringMVC还有些许地方不太懂，但是希望在自己整理的过程中，通过自己的不断尝试测试，整理出正确的一套SpringMVC知识点 1.三层架构和MVC1. 1 三层架构1. 咱们开发服务器端程序，一般都基于两种形式，一种C/S架构程序，一种B/S架构程序 2. 使用Java语言基本上都是开发B/S架构的程序，B/S架构又分成了三层架构 3. 三层架构 1. 表现层：WEB层，用来和客户端进行数据交互的。表现层一般会采用MVC的设计模型 2. 业务层：处理公司具体的业务逻辑的 3. 持久层：用来操作数据库的 1.2 MVC模型1. MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。 2. Model：数据模型，JavaBean的类，用来进行数据封装。 3. View：指JSP、HTML用来展示数据给用户 4. Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。 2.SpringMVC环境搭建2.1 SpringMVC是什么？1. SpringMVC的概述 1. 是一种基于Java实现的MVC设计模型的请求驱动类型的轻量级WEB框架。 2. Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供 了构建 Web 应用程序的全功能 MVC 模块。 3. 使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的 SpringMVC框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts2等。 2. SpringMVC在三层架构中的位置 1. 表现层框架 3. SpringMVC的优势 4. SpringMVC和Struts2框架的对比 2.2 SpringMVC坐标库&lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-context&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-web&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-webmvc&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>javax.servlet&lt;/groupId> &lt;artifactId>servlet-api&lt;/artifactId> &lt;version>2.5&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>javax.servlet.jsp&lt;/groupId> &lt;artifactId>jsp-api&lt;/artifactId> &lt;version>2.0&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency> 2.3 在web.xml配置文件中配置前端控制器（DispatcherServlet）&lt;servlet> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;servlet-mapping> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;!-- 配置拦截路径 --> &lt;/servlet-mapping> 2.4 在资源文件下（resources）创建springmvc.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- 扫描包 --> &lt;context:component-scan base-package=\"cn.itcast.controller\"/> &lt;!-- 配置视图解析器 --> &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/> &lt;property name=\"suffix\" value=\".jsp\"/> &lt;/bean> &lt;!-- 开启配置器 --> &lt;mvc:annotation-driven/> &lt;/beans> 2.5 创建HelloControllerDemo 类（Controller）@Controller public class HelloControllerDemo { @RequestMapping(path = \"/hello\") public String sayHello(){ System.out.println(\"Welcome springmvc ... \"); return \"success\"; } } 2.6 在index.jsp中配置一个超链接，用来测试SpringMVC环境配置是否成功&lt;a href=\"hello\">入门开始&lt;/a> 注意：这里先选择性忽略部分注解的属性，先了解如何入门即可，在之后小编会做出注解的使用以及解释，这里主要是搭建环境测试是否入门 2.6.1 在WEB-INF下创建pages文件夹，在pages文件夹中创建success.jsp文件 2.7 配置Tomcat,这里小编以图文形式来讲解 2.7.1 创建Local Tomcat2.7.2 创建环境部署 2.7.3 添加项目部署 2.7.4 设置虚拟路径 2.8 启动服务器,进行测试 控制台输出：Welcome springmvc ... 最后跳转到界面： 好了，这里就是SpringMVC的入门架构了","categories":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/categories/Spring/"},{"name":"SpringMVC","slug":"Spring/SpringMVC","permalink":"https://nomessages.github.io.git/categories/Spring/SpringMVC/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://nomessages.github.io.git/tags/SpringMVC/"}]}],"categories":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/categories/Spring/"},{"name":"SpringMVC","slug":"Spring/SpringMVC","permalink":"https://nomessages.github.io.git/categories/Spring/SpringMVC/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://nomessages.github.io.git/categories/SpringMVC/"},{"name":"Spring","slug":"SpringMVC/Spring","permalink":"https://nomessages.github.io.git/categories/SpringMVC/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://nomessages.github.io.git/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://nomessages.github.io.git/tags/SpringMVC/"}]}