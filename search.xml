<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringMVC 学习心得（八）</title>
      <link href="/2020/06/11/thrid-post-artical/"/>
      <url>/2020/06/11/thrid-post-artical/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC-学习心得-（八）"><a href="#SpringMVC-学习心得-（八）" class="headerlink" title="SpringMVC 学习心得 （八）"></a>SpringMVC 学习心得 （八）</h2><p><strong>异常流程处理过程，出现异常之后都会默认向上抛出异常直到有人处理，如果整个过程中一直没有人去处理，那么将会将异常抛给浏览器（也就是用户），这样对用户的体验是非常不友好的，所以我们应该要手动去处理这些异常，以展示友好界面</strong></p><p><img src="https://img-blog.csdnimg.cn/2020052817052197.png" alt></p><h3 id="1-、自定义异常处理器"><a href="#1-、自定义异常处理器" class="headerlink" title="1)、自定义异常处理器"></a>1)、自定义异常处理器</h3><h5 id="1-自定义异常SysException类"><a href="#1-自定义异常SysException类" class="headerlink" title="1).自定义异常SysException类"></a>1).自定义异常SysException类</h5><blockquote><p>public class SysException extends Exception {<br>    private String msg;</p><p>public SysException(String msg) {<br>    this.msg = msg;<br>}</p><p>public String getMsg() {<br>    return msg;<br>}</p><p>public void setMsg(String msg) {<br>    this.msg = msg;<br>}</p><p>}</p></blockquote><h5 id="2-实现HandlerExceptionResolver"><a href="#2-实现HandlerExceptionResolver" class="headerlink" title="2).实现HandlerExceptionResolver"></a>2).实现HandlerExceptionResolver</h5><blockquote><p>public class SysExceptionResolver implements HandlerExceptionResolver {</p><p>@Override<br>public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {<br>    //controller 抛出的异常对象Exception ex<br>        SysException sys = null;<br>    if(e instanceof SysException){<br>        sys = (SysException) e;<br>    }else{<br>    //如果没有就抛出异常<br>        sys = new SysException(“服务器异常”);<br>    }<br>    //创建modelAndView对象<br>    ModelAndView modelAndView = new ModelAndView();<br>    modelAndView.addObject(“msg”,sys.getMsg());<br>    //选择异常跳转视图<br>    modelAndView.setViewName(“error”);<br>    return modelAndView;<br>}</p><p>}</p></blockquote><h5 id="3-、配置异常处理器"><a href="#3-、配置异常处理器" class="headerlink" title="3)、配置异常处理器"></a>3)、配置异常处理器</h5><blockquote><p> &lt; bean id=”sysExceptionResolver” class=”cn.itcast.exception.SysExceptionResolver” /&gt;</p></blockquote><h3 id="2-、拦截器（Interceptor）"><a href="#2-、拦截器（Interceptor）" class="headerlink" title="2)、拦截器（Interceptor）"></a>2)、拦截器（Interceptor）</h3><h5 id="1-拦截器和过滤器的区别？"><a href="#1-拦截器和过滤器的区别？" class="headerlink" title="1).拦截器和过滤器的区别？"></a>1).拦截器和过滤器的区别？</h5><blockquote><ol><li>过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术</li><li>拦截器是<strong>SpringMVC框架独有的</strong></li><li>过滤器配置了/*，可以拦截任何资源。</li><li>拦截器只会对<strong>控制器中的方法</strong>进行拦截</li></ol></blockquote><h5 id="2-自定义拦截器步骤"><a href="#2-自定义拦截器步骤" class="headerlink" title="2).自定义拦截器步骤"></a>2).自定义拦截器步骤</h5><p><strong>1.实现HandlerInterceptor接口，重写public boolean preHandle（）方法</strong></p><blockquote><p>public class MyInteceptorHandler implements HandlerInterceptor {<br>    //最先被执行，在controller之前<br>    @Override<br>    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {<br>        System.out.println(“拦截器开始执行咯。。”);<br>        return true;<br>    }<br>//在controller执行之后再执行<br>    @Override<br>    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {<br>        System.out.println(“posthandle…”);<br>        //这里实现页面转发，跳到index.jsp页面中<br>        request.getRequestDispatcher(“/index.jsp”).forward(request,re    sponse);<br>        System.out.println(“拦截器执行完咯。。”);</p><p>}</p><p>//在之后执行的方法<br>    @Override<br>    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {<br>        System.out.println(“拦截器执行完之后咯。。”);<br>    }<br>}</p></blockquote><p><strong>2.配置springmvc配置文件注册拦截器作用范围</strong></p><blockquote><p>  <a href="mvc:interceptors">mvc:interceptors</a><br>        <a href="mvc:interceptor">mvc:interceptor</a><br>            <!-- 设置哪些路径被拦截 --><br>            &lt;mvc:mapping path=”/hello”/&gt;<br>            <!-- 设置哪些路径不被拦截 --><br>            &lt;mvc:exclude-mapping path=”/“/&gt;<br>            <bean id="myInteceptorHandler" class="cn.itcast.controller.MyInteceptorHandler"><br>        <br>    </bean></p></blockquote><p><strong>3.controller跳转到success.jsp界面</strong></p><blockquote><p>@RequestMapping(“/hello”)<br>    public String hello(){<br>        System.out.println(“hello方法。。。”);<br>        return “success”;<br>    }</p></blockquote><p><strong>注意：小编在index.jsp和success.jsp中都输出了一句话以证明拦截器的执行流程</strong></p><h5 id="3-拦截器执行过程"><a href="#3-拦截器执行过程" class="headerlink" title="3).拦截器执行过程"></a>3).拦截器执行过程</h5><p><img src="https://img-blog.csdnimg.cn/20200528194212163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQwOTk5NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>控制台打印，首先走的是preHandle方法，其次就是controller,然后走的postHandle方法，再走的controller的视图解析器，最后走的afterHandle方法</strong></p><p><img src="https://img-blog.csdnimg.cn/20200528195846130.png" alt="在这里插入图片描述"><br><strong>注意：最后显示的视图是index.jsp视图，原因是 如果postHandler中指定了跳转的页面，那么controller方法跳转的页面将不会显示，所以最终显示的是index.jsp界面</strong><br><img src="https://img-blog.csdnimg.cn/20200528200159121.png" alt="在这里插入图片描述"></p><h5 id="4-单个拦截器使用总结"><a href="#4-单个拦截器使用总结" class="headerlink" title="4).单个拦截器使用总结"></a>4).单个拦截器使用总结</h5><blockquote><ol><li>preHandle方法是controller方法执行前拦截的方法<ol><li>可以使用request或者response跳转到指定的页面</li><li>return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。</li><li>return false不放行，不会执行controller中的方法。</li></ol></li><li>postHandle是controller方法执行后执行的方法，在JSP视图执行前。<ol><li>可以使用request或者response跳转到指定的页面</li><li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。</li></ol></li><li>postHandle方法是在JSP执行后执行<ol><li>request或者response不能再跳转页面了</li></ol></li></ol></blockquote><h3 id="3-、多个拦截器定义的使用"><a href="#3-、多个拦截器定义的使用" class="headerlink" title="3)、多个拦截器定义的使用"></a>3)、多个拦截器定义的使用</h3><h5 id="1-执行顺序？"><a href="#1-执行顺序？" class="headerlink" title="1).执行顺序？"></a>1).执行顺序？</h5><p><strong>a).多个拦截器全部都放行的执行顺序：</strong><br><img src="https://img-blog.csdnimg.cn/20200528204821734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQwOTk5NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>拦截器111开始执行咯。。<br>拦截器2开始执行咯。。<br>hello方法。。。<br>拦截器执2行完咯。。<br>拦截器执2行完之后咯。。<br>拦截器111执行完之后咯。。</p></blockquote><p><strong>b).多个拦截器后者不放行的执行顺序：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200528205907818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQwOTk5NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>控制台打印：<br>拦截器111开始执行咯。。<br>拦截器2开始执行咯。。<br>拦截器111执行完之后咯。。</p></blockquote><p><strong>这里小编对没有页面显示也还有些疑问，显示的是空白页面，在不断的学习和探索之后再进行回更，多拦截器执行原理！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
